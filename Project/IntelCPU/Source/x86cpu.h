/////////////////////////////////////////////////////////////////////////
// $Id: x86cpu.h,v 1.0 2002/10/08 13:10:37 bdenney Exp $
/////////////////////////////////////////////////////////////////////////

#ifndef X86_CPU_H
#define X86_CPU_H

#if 0 // no bochs
#define LOG_THIS BX_CPU_THIS_PTR
#define NEED_CPU_REG_SHORTCUTS 1
#include "bochs.h"

#else

#define LOG_THIS BX_CPU_THIS_PTR
#define NEED_CPU_REG_SHORTCUTS 1

#include "iconfig.h"      /* generated by configure script from config.h.in */
#include "instrume.h"

extern "C" {
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <string.h>
#include <fcntl.h>
}

#undef BX_SUPPORT_PAGING
#undef BX_USE_TLB

#define BX_USE_MEM_SMF 0

#if BX_USE_MEM_SMF
// if static member functions on, then there is only one memory
#  define BX_MEM_SMF  static
#else
#  define BX_MEM_SMF
#endif

class BX_CPU_C;

class BX_MEM_C //: public logfunctions
{
public:
	Bit8u   *_vector;
	size_t  len;
	size_t  megabytes;  // (len in Megabytes)
#if BX_DEBUGGER
	unsigned char dbg_dirty_pages[(BX_MAX_DIRTY_PAGE_TABLE_MEGS * 1024 * 1024) / 4096];
	Bit32u dbg_count_dirty_pages () {
    return (BX_MAX_DIRTY_PAGE_TABLE_MEGS * 1024 * 1024) / 4096;
  }
#endif

	BX_MEM_C(void){};
	BX_MEM_C(size_t memsize){};
	~BX_MEM_C(void){};
	BX_MEM_SMF void  init_memory(int memsize);
	BX_MEM_SMF void  read_physical(BX_CPU_C *cpu, Bit32u addr, unsigned len, void *data){};
	BX_MEM_SMF void  write_physical(BX_CPU_C *cpu, Bit32u addr, unsigned len, void *data){};
};


#if BX_DEBUGGER
#  define BX_DBG_DIRTY_PAGE(page) BX_MEM(0)->dbg_dirty_pages[page] = 1;
#else
#  define BX_DBG_DIRTY_PAGE(page)
#endif

#include "cpu.h"

#  define UNUSED(offset)			(offset)
#  define A20ADDR(x)                (x)
#  define BX_DBG_ASYNC_INTR 1
#  define BX_DBG_ASYNC_DMA  1
#  define BX_DBG_DMA_REPORT(addr, len, what, val)
#  define BX_DBG_IAC_REPORT(_vector, irq)
#  define BX_DBG_A20_REPORT(val)
#  define BX_DBG_IO_REPORT(addr, size, op, val)
#  define BX_DBG_UCMEM_REPORT(addr, size, op, val)


#define EMPTY		do { } while(0)
#define BX_INFO(x)  EMPTY
#define BX_DEBUG(x) EMPTY
#define BX_ERROR(x) EMPTY
#define BX_PANIC(x) EMPTY

#define BX_READ    10
#define BX_WRITE   11
#define BX_RW      12


#define BX_INP(addr,len) read_io_(addr,len)
#define BX_OUTP(addr,value,len) write_io_(addr,value,len)

#define BX_HRQ 0
#define BX_RAISE_HLDA() 0
#define BX_TICK1() 0
#define BX_TICKN
#define BX_INTR
#define BX_SET_INTR
#define BX_IAC() 0

#define put
#define settype
#define CPU0LOG 0

typedef struct {
  Boolean floppy;
  Boolean keyboard;
  Boolean video;
  Boolean disk;
  Boolean pit;
  Boolean pic;
  Boolean bios;
  Boolean cmos;
  Boolean a20;
  Boolean interrupts;
  Boolean exceptions;
  Boolean unsupported;
  Boolean temp;
  Boolean reset;
  Boolean debugger;
  Boolean mouse;
  Boolean io;
  Boolean xms;
  Boolean v8086;
  Boolean paging;
  Boolean creg;
  Boolean dreg;
  Boolean dma;
  Boolean unsupported_io;
  Boolean serial;
  Boolean cdrom;
#ifdef MAGIC_BREAKPOINT
  Boolean magic_break_enabled;
#endif /* MAGIC_BREAKPOINT */
#if BX_SUPPORT_APIC
  Boolean apic;
  Boolean ioapic;
#endif
#if BX_DEBUG_LINUX
  Boolean linux_syscall;
#endif
  void* record_io;
  } bx_debug_t;

#define BX_ASSERT(x) do {if (!(x)) BX_PANIC(("failed assertion \"%s\" at %s:%d\n", #x, __FILE__, __LINE__));} while (0)
void bx_signal_handler (int signum);
void bx_atexit(void);

extern bx_debug_t bx_dbg;

#define LOG_THIS BX_CPU_THIS_PTR

//#include "icpu_pc.h"
//#include "icpu_dos.h"
//#include "x86cpu_mswin.h"

#endif // no bochs


#endif //#ifndef X86_CPU_H


