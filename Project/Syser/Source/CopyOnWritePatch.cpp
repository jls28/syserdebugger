#include "StdAfx.h"
#include "Syser.h"
#include "CopyOnWritePatch.h"


void OnMiCopyOnWritePatchStart()
{
	ULONG_PTR	Flags;

	SyserSaveFlags(&Flags);
	SyserCloseInterrupt();
	DWORD dwOldCR0;
	NTSTATUS Result;
	ULONGLONG PhysAddr;
	ULPOS	PageAddr;
	CCodeBPMap::IT Iter;
	ULPOS VirtualAddress;

	if(gpSyser->m_bCopyOnWriteFastCall)
		VirtualAddress = Reg.GeneReg[ECX_IDX];
	else
		VirtualAddress = GET_DWORD(Reg.GeneReg[ESP_IDX],4);

	PageAddr = VirtualAddress & MP_NOT_MASK;
	for(Iter = gpSyser->m_SyserUI.m_CodeBPMap.Begin();Iter.IsExist();Iter++)
	{
		if((Iter->Address & MP_NOT_MASK)==PageAddr)
			break;
	}
	if(Iter.IsExist()==false)//没有虚拟地址和异常地址在同一页的断点，就返回
		goto local_1;
	if(MapToPAddr(PageAddr,&PhysAddr)==false)//页不存在
		goto local_1;
	for(Iter = gpSyser->m_SyserUI.m_CodeBPMap.Begin();Iter.IsExist();Iter++)
	{
		if(Iter->State == BP_STATE_ENABLE && (Iter->Address & MP_NOT_MASK)==PageAddr && (Iter.Key()&MP64_NOT_MASK)==PhysAddr)
		{
			dwOldCR0 = SyserClearCR0WP();
			if(SafeWriteByte(*(void**)&Iter->Address,Iter->CodeBackup))
				Iter->State = BP_STATE_RECOV_COPY_ON_WRITE;
			SyserRestoreCR0WP(dwOldCR0);
		}
	}
local_1:
	SyserRestoreFlags(Flags);
}

void OnMiCopyOnWritePatchEnd()
{
	ULONG_PTR	Flags;

	SyserSaveFlags(&Flags);
	SyserCld();

	DWORD dwOldCR0;
	ULONGLONG PhysAddr;
	CCodeBPMap::IT Iter;
AgainRecov:
	for(Iter = gpSyser->m_SyserUI.m_CodeBPMap.Begin();Iter.IsExist();Iter++)
	{
		if(Iter->State!=BP_STATE_RECOV_COPY_ON_WRITE)
			continue;
		if(MapToPAddr(Iter->Address,&PhysAddr)==false)
		{//映射失败删除此断点
			gpSyser->m_SyserUI.m_CodeBPMap.Remove(Iter);
			goto AgainRecov;
		}
		if(Iter.Key()==PhysAddr)
		{//物理地址未改变则写回CC
			dwOldCR0 = SyserClearCR0WP();
			if(SafeWriteByte(*(void**)&Iter->Address,0xcc))
				Iter->State = BP_STATE_ENABLE;
			SyserRestoreCR0WP(dwOldCR0);
		}
		else
		{//处理断点物理地址改变
			//OUTPUT(WSTR("Phys Change %08X->%08X %08X\n"),Iter->Address,(ULPOS)Iter.Key(),(ULPOS)PhysAddr);
			BREAK_POINT CodeBP = *Iter;
			gpSyser->m_SyserUI.m_CodeBPMap.Remove(Iter);
			Iter = gpSyser->m_SyserUI.m_CodeBPMap.InsertUnique(PhysAddr,CodeBP);
			if(Iter.IsExist())
			{
				dwOldCR0 = SyserClearCR0WP();
				if(SafeWriteByte(*(void**)&Iter->Address,0xcc))
					Iter->State = BP_STATE_ENABLE;
				SyserRestoreCR0WP(dwOldCR0);
				goto AgainRecov;
			}
		}
	}

	SyserRestoreFlags(Flags);
}

int GetFuncReturn(BYTE*CodeBuff,int MaxSize)
{
	bool	bRetExist;
	ULPOS	Address,MaxJmpAddr,DesAddr,LastRet;
	int		CodeLen;
	BYTE	OpCode,*Buffer;
	Address = 0;
	LastRet = 0;
	MaxJmpAddr = 0;
	bRetExist = false;
	while(Address < (ULPOS)MaxSize)
	{
		Buffer = &CodeBuff[Address];
		OpCode =*Buffer;
		CodeLen = CInstrSym::InstrLen(Buffer,MaxSize-Address);
		MIN_LIMIT(CodeLen,1);
		if(bRetExist==false && (OpCode==0xC3 || OpCode==0xC2))
		{
			LastRet = Address;
			bRetExist = true;
		}
		if(Address==0 && OpCode==0xE9)
			return 	Address+CodeLen;
		if(OpCode==0xEB || (OpCode>=0x70 && OpCode<=0x7f))
		{
			DesAddr = Address+(char)Buffer[1]+2;
			if(DesAddr>MaxJmpAddr)
				MaxJmpAddr = DesAddr;
		}
		else if(OpCode==0x0F && (Buffer[1]>=0x80 && Buffer[1]<=0x8F))
		{
			DesAddr = Address+(int)GET_DWORD(Buffer,2)+6;
			if(DesAddr>MaxJmpAddr)
				MaxJmpAddr = DesAddr;
		}
		if(Address>=MaxJmpAddr)
		{
			if(	OpCode==0xCC || OpCode==0xC3 || OpCode==0xC2 || 
				(OpCode==0xE9 && (int)GET_DWORD(Buffer,1) < 0) ||
				(OpCode==0xEB && (char)GET_BYTE(Buffer,1) < 0) && bRetExist)
			{
				return 	Address;
			}
		}
		Address+=CodeLen;
	}
	if(bRetExist)
		return LastRet;
	return 0;
}

//去特征串用FF略过可变字节，例如全局变量地址和JMP偏移

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE W2K_ntkrnlpa[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x2C, 0x53, 0x8B, 0xDA, 0x89, 0x4D, 0xE0, 0x56, 0x8B, 0x03, 0x33,
	0xC9, 0x89, 0x45, 0xD4, 0x8B, 0x43, 0x04, 0x89, 0x45, 0xD8, 0x8B, 0x03, 0x25, 0x00, 0x02, 0x00,
	0x00, 0x57, 0x0B, 0xC1, 0x89, 0x4D, 0xF4, 0x75, 0x07, 0xC7, 0x45, 0xF4, 0x01, 0x00, 0x00, 0x00
};

BYTE W2K_ntoskrnl[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x28, 0x83, 0x65, 0xF0, 0x00, 0x53, 0x8B, 0x1A, 0x56, 0xF6, 0xC7, 
	0x02, 0x57, 0x89, 0x55, 0xF4, 0x89, 0x4D, 0xDC, 0x89, 0x5D, 0xEC, 0x75, 0x07, 0xC7, 0x45, 0xF0, 
	0x01, 0x00, 0x00, 0x00, 0x8B, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xEB, 0x0C, 0x8D, 0x04, 0x5B, 
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BYTE XP_SP2_ntkrnlpa[]=
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x2C, 0x83, 0x65, 0xF0, 0x00, 0x53, 0x56, 0x57, 0x89,
	0x55, 0xF4, 0x89, 0x4D, 0xE0, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x58, 0x44, 0x8B, 0x0A,
	0x8B, 0x7A, 0x04, 0x8B, 0xC1, 0x25, 0x00, 0x02, 0x00, 0x00, 0x33, 0xF6, 0x0B, 0xC6, 0x89, 0x4D
};

BYTE XP_SP2_ntoskrnl[]=
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x28, 0x53, 0x56, 0x33, 0xF6, 0x57, 0x89, 0x55, 0xF4, 
	0x89, 0x4D, 0xDC, 0x89, 0x75, 0xF0, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x58, 0x44, 0x8B, 
	0x02, 0xF6, 0xC4, 0x02, 0x89, 0x45, 0xEC, 0x0F, 0x84, 0xFF, 0xFF, 0xFF, 0xFF, 0x8B, 0x0D
};

BYTE XP_SP1_ntoskrnl[]=
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x24, 0x53, 0x56, 0x57, 0x33, 0xFF, 0x89, 0x55, 0xF8, 0x89, 0x4D, 
	0xF0, 0x89, 0x7D, 0xEC, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x4D, 0xF8, 0x8B, 0x58, 0x44, 
	0x8B, 0x01, 0xF6, 0xC4, 0x02, 0x89, 0x45, 0xE8, 0x75, 0xFF, 0xC7, 0x45, 0xEC, 0x01, 0x00, 0x00, 
};

BYTE XP_ntoskrnl[] =
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x24, 0x53, 0x56, 0x57, 0x33, 0xFF, 0x89, 0x55, 0xF8, 0x89, 0x4D, 
	0xF0, 0x89, 0x7D, 0xEC, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x4D, 0xF8, 0x8B, 0x58, 0x44, 
	0x8B, 0x01, 0xF6, 0xC4, 0x02, 0x89, 0x45, 0xE8, 0x0F, 0x84, 0xFF, 0xFF, 0xFF, 0xFF, 0x8B, 0x15, 
} ;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BYTE W2003_ntkrnlpa[]=
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x30, 0x53, 0x83, 0x65, 0xE4, 0x00, 0x83, 0x65, 0xE8, 0x00, 0x56, 
	0x8B, 0xF2, 0x8B, 0x46, 0x04, 0x57, 0x8B, 0x3E, 0x89, 0x45, 0xD4, 0x8B, 0xD7, 0x0F, 0xAC, 0xC2, 
	0x0C, 0x8B, 0xDA, 0x81, 0xE3, 0xFF, 0xFF, 0xFF, 0x03, 0x89, 0x5D, 0xD8, 0x6B, 0xDB, 0x1C, 0x03, 
};

BYTE W2003_ntoskrnl[]=
{
	0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x2C, 0x53, 0x56, 0x8B, 0x32, 0x8B, 0xC6, 0xC1, 0xE8, 0x0C, 0x8B, 
	0xD9, 0x8B, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xD8, 0x8D, 0x04, 0x40, 0x57, 0x8D, 0x3C, 
	0xC1, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x40, 0x44, 0x33, 0xC9, 0x3B, 0x1D
};

BYTE W2003_SP1_ntkrnlpa[]=
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x34, 0x8B, 0x42, 0x04, 0x53, 0x56, 0x8B, 0xF1, 0x57, 
	0x8B, 0x3A, 0x89, 0x45, 0xD0, 0x8B, 0xCF, 0x0F, 0xAC, 0xC1, 0x0C, 0x8B, 0xD9, 0x81, 0xE3, 0xFF, 
	0xFF, 0xFF, 0x03, 0x89, 0x5D, 0xD4, 0x6B, 0xDB, 0x1C, 0x03, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 
};

BYTE W2003_SP1_ntoskrnl[]=
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xEC, 0x30, 0x53, 0x56, 0x57, 0x8B, 0x3A, 0x8B, 0xC7, 0xC1, 
	0xE8, 0x0C, 0x8B, 0xF1, 0x8B, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0x89, 0x45, 0xD0, 0x8D, 0x04, 0x40, 
	0x8D, 0x1C, 0xC1, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x40, 0x38, 0x33, 0xC9, 0x3B, 0x35, 
} ;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE Vista_ntkrnlpa[] =
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x54, 0x83, 0x64, 0x24, 0x14, 0x00, 
	0x53, 0x56, 0x8B, 0x75, 0x0C, 0x8B, 0x0E, 0x57, 0x89, 0x4C, 0x24, 0x50, 0x8B, 0x46, 0x04, 0x89, 
	0x44, 0x24, 0x54, 0x89, 0x4C, 0x24, 0x48, 0x89, 0x44, 0x24, 0x4C, 0x0F, 0xAC, 0xC1, 0x0C, 0x8B, 
	0xD9, 0x81, 0xE3, 0xFF, 0xFF, 0xFF, 0x03, 0x8B, 0xFB, 0x6B, 0xFF, 0x1C
};

BYTE Vista_ntoskrnl[] =
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x3C, 0x8B, 0x45, 0x0C, 0x83, 0x64, 
	0x24, 0x14, 0x00, 0x53, 0x56, 0x57, 0x8B, 0x38, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x0D, 
	0xFF, 0xFF, 0xFF, 0xFF, 0x8B, 0x40, 0x48, 0x89, 0x7C, 0x24, 0x28, 0xC1, 0xEF, 0x0C, 0x8B, 0xF7, 
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BYTE VistaSP1_ntkrnlpa_6000_16584[] =
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x54, 0x8B, 0x45, 0x0C, 0x83, 0x64,
	0x24, 0x1C, 0x00, 0x53, 0x56, 0x8B, 0x30, 0x57, 0x89, 0x74, 0x24, 0x48, 0x8B, 0x40, 0x04, 0x89,
	0x44, 0x24, 0x4C, 0x89, 0x74, 0x24, 0x50, 0x89, 0x44, 0x24, 0x54, 0x8B, 0xCE, 0x0F, 0xAC, 0xC1,
	0x0C, 0x8B, 0xD9, 0x81, 0xE3, 0xFF, 0xFF, 0xFF, 0x03, 0x8B, 0xFB, 0x6B, 0xFF, 0x1C
};

BYTE VistaSP1_ntoskrnl_6000_16584[] =
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x3C, 0x8B, 0x45, 0x0C, 0x83, 0x64,
	0x24, 0x24, 0x00, 0x53, 0x56, 0x57, 0x8B, 0x38, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x0D,
	0xFF, 0xFF, 0xFF, 0xFF, 0x8B, 0x40, 0x48, 0x89, 0x7C, 0x24, 0x24, 0xC1, 0xEF, 0x0C, 0x8B, 0xF7,
	0x6B, 0xF6, 0x18, 0x03, 0x35
};

BYTE VistaSP1_ntkrnlpa_6001_18000[] =
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x5C, 0x8B, 0x45, 0x0C, 0x83, 0x64,
	0x24, 0x28, 0x00, 0x53, 0x56, 0x8B, 0x30, 0x57, 0x89, 0x74, 0x24, 0x58, 0x8B, 0x48, 0x04, 0x89,
	0x4C, 0x24, 0x5C, 0x89, 0x74, 0x24, 0x50, 0x89, 0x4C, 0x24, 0x54, 0x8B, 0xC6, 0x0F, 0xAC, 0xC8
};

BYTE VistaSP1_ntoskrnl_6001_18000[] =
{
	0x8B, 0xFF, 0x55, 0x8B, 0xEC, 0x83, 0xE4, 0xF8, 0x83, 0xEC, 0x3C, 0x8B, 0x45, 0x0C, 0x83, 0x64,
	0x24, 0x28, 0x00, 0x53, 0x56, 0x8B, 0x30, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x48, 0x48,
	0xA1, 0xFF, 0xFF, 0xFF, 0xFF, 0x89, 0x74, 0x24, 0x20, 0xC1, 0xEE, 0x0C, 0x8B, 0xDE, 0x6B, 0xDB,
	0x18
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ST_COPY_ON_WRITE_OS_INFO CopyOnWriteOSInfo[]=
{
	///////////////////XP SP2////////////////////
	{
		XP_SP2_ntkrnlpa,
		sizeof(XP_SP2_ntkrnlpa),
		true,5,1
	},
	{
		XP_SP2_ntoskrnl,
		sizeof(XP_SP2_ntoskrnl),
		true,5,1
	},
	{
		XP_SP1_ntoskrnl,
		sizeof(XP_SP1_ntoskrnl),
		true,5,1
	},
	{
		XP_ntoskrnl,
		sizeof(XP_ntoskrnl),
		true,5,1
	},
	///////////////////2K////////////////////////
	{
		W2K_ntkrnlpa,
		sizeof(W2K_ntkrnlpa),
		true,5,0
	},
	{
		W2K_ntoskrnl,
		sizeof(W2K_ntoskrnl),
		true,5,0
	},
	///////////////////Vista/////////////////////
	{
		Vista_ntkrnlpa,
		sizeof(Vista_ntkrnlpa),
		false,6,0
	},
	{
		Vista_ntoskrnl,
		sizeof(Vista_ntoskrnl),
		false,6,0
	},
	{
		VistaSP1_ntkrnlpa_6000_16584,
		sizeof(VistaSP1_ntkrnlpa_6000_16584),
		false,6,0
	},
	{
		VistaSP1_ntoskrnl_6000_16584,
		sizeof(VistaSP1_ntoskrnl_6000_16584),
		false,6,0
	},
	{
		VistaSP1_ntkrnlpa_6001_18000,
		sizeof(VistaSP1_ntkrnlpa_6001_18000),
		false,6,0
	},
	{
		VistaSP1_ntoskrnl_6001_18000,
		sizeof(VistaSP1_ntoskrnl_6001_18000),
		false,6,0
	},	
	///////////////////W2003/////////////////////
	{
		W2003_ntkrnlpa,
		sizeof(W2003_ntkrnlpa),
		true,5,2
	},
	{
		W2003_ntoskrnl,
		sizeof(W2003_ntoskrnl),
		true,5,2
	},
	{
		W2003_SP1_ntkrnlpa,
		sizeof(W2003_SP1_ntkrnlpa),
		true,5,2
	},
	{
		W2003_SP1_ntoskrnl,
		sizeof(W2003_SP1_ntoskrnl),
		true,5,2
	},
	/////////////////////////////////////////////
	{
		NULL,0,false
	}
	/////////////////////////////////////////////
};

ULSIZE GetModuleValidSize(ULPOS BaseAddr,ULSIZE Size)
{
	ULSIZE ValidSize = 0;
	while(Size>0)
	{
		if(MmIsAddressValid(RT_PVOID(BaseAddr,ValidSize))==false)
			return ValidSize;
		if(Size>MP_SIZE)
		{
			ValidSize+=MP_SIZE;
			Size-=MP_SIZE;
		}
		else
		{
			ValidSize+=Size;
			Size=0;
		}
	}
	return ValidSize;
}

void PatchMiCopyOnWrite()
{
	ULSIZE SeachSize;
	ULPOS FuncStart,FuncReturn;
	ULONG MajorVersion,MinorVersion;
	PsGetVersion(&MajorVersion,&MinorVersion,NULL,NULL);
	CDbgModule*pDbgModule = gpSyser->m_pSysDebugger->GetModule((ULPOS)KeClearEvent);
	if(pDbgModule==NULL)
		return;
	SeachSize = GetModuleValidSize(pDbgModule->m_ModuleBase,MIN(pDbgModule->m_ModuleSize,0x100000));
	FuncStart = 0;
	int n;
	for(n=0;CopyOnWriteOSInfo[n].CodeFeature;n++)
	{
		if(MajorVersion!=CopyOnWriteOSInfo[n].MajorVersion || MinorVersion!=CopyOnWriteOSInfo[n].MinorVersion)
			continue;
		FuncStart = (ULPOS) CodeSearch((void*)pDbgModule->m_ModuleBase,SeachSize,CopyOnWriteOSInfo[n].CodeFeature,CopyOnWriteOSInfo[n].CodeFeatureLen);
		if(FuncStart)
			break;
	}
	if(FuncStart==0)
		return;
	int FuncSize=GetFuncReturn((BYTE*)FuncStart,0x10000);
	if(FuncSize==0)
	{
		DbgPrint("Syser : Fail to local MiCopyOnWrite return!\n");
		return;
	}
	FuncReturn = FuncStart+FuncSize;
	gpSyser->m_bCopyOnWriteFastCall = CopyOnWriteOSInfo[n].bIsFastCall;
	gpSyser->m_bPatchCopyOnWrite = true;
	PATCH_SYSTEM("MiCopyOnWrite",FuncStart,OnMiCopyOnWritePatchStart);
	PATCH_SYSTEM("MiCopyOnWrite Return",FuncReturn,OnMiCopyOnWritePatchEnd);
}

